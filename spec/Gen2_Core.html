<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <title>Gen2 - Core</title>
    <script 
      src='https://www.w3.org/Tools/respec/respec-w3c-common' 
      class='remove'></script>
    <script type="text/javascript" src="plantuml/jquery.js"></script>
    <script type="text/javascript" src="plantuml/jquery_plantuml.js"></script>
    <script type="text/javascript" src="plantuml/rawdeflate.js"></script>	 
    <script class='remove'>
      var respecConfig = {
        specStatus: "ED",
        editors: [{
          name: "Ulf Bjorkengren",
          company: "Geotab",
          companyURL: "https://www.geotab.com"
        },
        {
          name: "Ulf Bjorkengren",
          company: "Volvo Cars",
          companyURL: "https://www.volvocars.com/intl"
        },
        {
          name: "Patrick LÃ¼nnemann",
          company: "Volkswagen Group",
          companyURL: "https://www.volkswagenag.com",
          w3cid: 95844
        },{
          name: "Isaac Agudo",
          company: "NICS Lab / University of Malaga",
          companyURL: "https://www.nics.uma.es"
        }],
        edDraftURI: "https://github.com/w3c/automotive/blob/gh-pages/spec/Gen2_Core.html",
        shortName: "Gen2-CORE",
        localBiblio: {
          "SemVer": {
            title: "Semantic Versioning 2.0.0",
            href: "https://semver.org/spec/v2.0.0.html",
            status: "published",
            publisher: "Tom Preston-Werner"
          }
        }
      };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        This document, the Gen2 core specification, describes the Gen2 messaging layer. 
        The companion specifications for the Gen2 transport protocols detail the mapping of the messaging layer to selected transports.
        The ontologies based on the Gen2 core specification are defined in documents for each specific domain
        (e.g. navigation, media, vehicle data). 
      </p>
    </section>
    <section id='sotd'></section>

    <section id="introduction">
      <h2>Introduction</h2>
      <p>
        This document describes the messaging API for Gen2 protocol. 
        This includes the messaging layer and set of rules for structuring data.
        The separation between payload encoding (transport) and messaging API (core) improves adaptability. 
        Extending and describing multiple transport protocols becomes possible.
      </p>     
      <p>
        The messages are exchanged between a <a>server</a> implementation holding the representation of data 
        and a <a>client</a> using the data.
      </p>
      <p>
        The Gen2 messaging layer uses a RESTful design for all methods exchanged via the interface (<a href="#interface"></a>).
      </p>
      <p>
        The Gen2 data structuring rules (<a href="http://genivi.github.io/vehicle_signal_specification/">VSS Rule set</a>) are the same through all transport protocols.
        The basis for structuring data hold by a <a>server</a> is a tree.
      </p>
    </section>

    <section id="conformance"></section>
    <section id="terms">
      <h2>Terminology</h2>
      <p>The acronym 'Gen2' is used to refer to this document, the second generation specification. The acronym 'VSS' is used to refer to the 'Vehicle Signal Specification' which is defined by the GENIVI Alliance. The term 'WebSocket' when used in this document, is as defined in the W3C WebSocket API and the WebSocket Protocol.</p>
    </section>
    <section data-dfn-for="data-model">
      <h2>Data model</h2>
		<p>

The service is intended for use with a tree-like logical taxonomy to
represent the vehicle data. An illustrative example of such a tree
structure is shown in <a href="#tree-example">Figure 1</a>. While it
is meant to support conforming taxonomies it was created principally
with the <a href="https://github.com/GENIVI/vehicle_signal_specification">Vehicle Signal Specification</a> (VSS) in mind. For more
details, see the <a href="http://genivi.github.io/vehicle_signal_specification/">VSS documentation</a>.
		</p>
    <figure id="tree-example" class="example">
			<img uml='
			@startuml 
				skinparam component {
					BorderColor Black
					FontSize 16
					
					BackgroundColor<<branch>> MediumSeaGreen
					FontColor<<branch>> White
					
					BackgroundColor<<rbranch>> Red
					FontColor<<rbranch>> White
					
					BackgroundColor<<attribute>> Yellow
					FontColor<<attribute>> Black
					
					BackgroundColor<<sensor>> CornflowerBlue
					FontColor<<sensor>> White
					
					BackgroundColor<<actuator>> DarkGrey
					FontColor<<actuator>> White
					
					BackgroundColor<<element>> LightCoral
					FontColor<<element>> White				
				}
				[Vehicle] -- [Navigation]
				[Vehicle] -- [Car]
				[Vehicle] -- [Private]
				[Vehicle]<<branch>>
				[Navigation]<<branch>>
				[Private]<<branch>>
				[Car]<<branch>>
				
				[Navigation] -- [...]
				[...]<<branch>>
				
				[Car] -- [Engine]
				[Car] -- [Body]
				[Engine]<<branch>>
				[Body]<<branch>>
				
				[Engine] -- [RPM]
				[Engine] -- [Speed]
				[Engine] -- [Fueltype]
				[RPM]<<sensor>>
				[Speed]<<sensor>>
				[Fueltype]<<attribute>>
				
				[Body] -- [Mirror]
				[Body] -- [Door]
				[Body] -- [Weight]
				[Mirror]<<branch>>
				[Door]<<branch>>
				[Weight]<<attribute>>
				
				[Door] -- [&nbsp;...&nbsp;]
				[&nbsp;...&nbsp;]<<branch>>
				
				[Mirror] -- [Left]
				[Left] -- [Heated]
				[Left] -- [Dimmed]
				[Left] -- [Fold]
				[Left]<<branch>>
				[Right]<<branch>>
				[Heated]<<sensor>>
				[Dimmed]<<sensor>>
				[Fold]<<actuator>>
				
				[Mirror] -- [Right]
				[Right] -- [ ... ]
				[ ... ]<<branch>>
				
			@enduml
			'>
        <figcaption>Diagram showing an example VSS 2.0 tree.</figcaption>
      </figure>
<div class="issue">VSS does not have a "domain root node" for the vehicle signal domain, like the Car node in Fig 1. To be introduced in VSS, or removed from here?</div>

      <section data-dfn-for="address">
        <h2>Addressing</h2>
        <p>Addressing of elements is done using URIs as defined in [[RFC3986]].</p>
        <blockquote><a>scheme</a>:<a>authority</a>/<a>path</a>?<a>query</a></blockquote>
        <p>The <dfn>scheme</dfn> describes the protocol to use to reach the addressed element.</p>
        <p>The <dfn>authority</dfn> describes where to reach the server holding and managing the data representation.
          Scheme and authority are defined within the protocol adaptation.</p>
        <p>The <dfn>path</dfn> consists of the slash delimited node names of the nodes traversed from the tree root to the tree leaf representing the data point. E. g. the path expression from traversing the nodes Vehicle, Car, Engine, RPM would be "Vehicle/Car/Engine/RPM".</p>
        <p>The <a>query</a> contains further information related to the request, see <a href="#filtering"></a>.
<div class="issue">VSS 2.0 should use slash as delimiter. If not, this difference should be pointed out here.</div>
      </section>
        <section id="service-discovery">
          <h2>Service discovery</h2>
          <p>The purpose of the data model is to provide a client with a description of the data that enables the client to make a request for desired vehicle data, and interpret the response. In order to obtain that description, the client MAY request that the server returns the VSS tree content, i. e. the metadata describing the accessible vehicle data. The client is able to request metadata from any point in the signal tree, such that only the metadata for the nodes within the given branch of the tree is returned. For example, only metadata for the chassis branch of the VSS tree is returned when the chassis path is specified. If the path is set to the VSS root, the response contains the metadata for the entire tree. If the server is able to satisfy the request it SHALL return a Response message. If an error occurs the server SHALL return an ErrorResponse message.<br>A service discovery request has the format of a read, where the path is appended with a query component, see <a href="#service-discovery-filter"></a> for the details.<br>The key data components of these messagess are defined below:</p>
          <ul>  
            <li>Request message parameters:</li>
            <ul>  
              <li>Path: The address to one or more nodes in the VSS tree, followed by the query component specifying the service discovery.</li>
            </ul>  
            <li>Response message parameters:</li>
            <ul>  
              <li>Metadata: The content of the VSS tree where the root is specified by the path.</li>
              <li>Timestamp: A timestamp associated with the request.</li>
            </ul>  
            <li>ErrorResponse message parameters: </li>
            <ul>  
              <li>Error: Information describing the error reason.</li>
              <li>Timestamp: A timestamp associated with the failed request.</li>
            </ul>  
          </ul>  
        <section id="dynamic-registry">
          <h2>Dynamic registry</h2>
          <p>To enable e. g. after-market services it SHALL be possible to dynamically add new branches to the VSS tree, and if requested also to delete them at a later point.<br>Requests of this type are not expected to be frequent for the type of data that is represented in the "vehicle signal domain", which is the current scope of VSS. These requests are therefore partitioned in a separate API, which is described in "Appendix: Dynamic registry API". </p>
        </section>
        </section>
    </section>
	
    <section id="filtering">
      <h2>Filtering</h2>
	  <p>Filtering is a mechanism to refine a client request, in order to more precisely control the data in a response. Filtering can be applied in read requests and in subscribe requests.For read requests the filter expression MUST be appended to the request path in the form of a <a>query</a> component following the description in [[RFC3986]]. For subscribe requests the filter expression MUST be carried in the request payload. The filter expression follows the same general rules in both request cases. The query component must have the following structure<br>
  <dfn>reserved-word comparison-operator expression</dfn><br>
where<br>
  - reserved-word must have the dollar-sign as the first character ($). The availabe reserved words are described in the chapters below.<br>
  - comparison-operator is one of either the equal sign (EQ), the greater than sign (GT), or the less than sign (LT).<br>
  - expression is a character string with its interpretation given by the preceeding reserved-word and comparison operator.<br><br>
Filter expressions can consist of multiple query expressions, as described in <a href="#filter-combinations"></a>.<br><br>
As filtering is implemented on the server side, in vehicles, the filtering complexity is intentionally kept to a low level in order to not load the processing resources too much.
	  </p> 
     <section data-dfn-for="read-filter">
        <h3>Read filtering</h2>
		<p>The available read filtering options are presented in the following chapters, and are only applicable to read requests. As described in [[RFC3986]], a question mark must be inserted as a delimiter between the path and the query components.
		</p>
       <section data-dfn-for="service-discovery-filter">
          <h3>Service discovery filter</h2>
		<p>The service discovery query has the structure<br>
  <dfn>$spec EQ depth</dfn><br>
where<br>
  - $spec is the reserved word for service discovery filtering.<br>
  - the equal sign (EQ) is the only allowed comparison operator for service discovery filtering.<br>
  - depth sets the maximum branch depth that is returned in the response, counted from the root node given by the path component in the request.
Depth MUST be a positive integer. If set to zero, it is replaced by the max depth of the subtree.
		</p>
        </section>
       <section data-dfn-for="search-filter">
          <h3>Search filter</h2>
		<p>If the path in a read request does not terminate in a leaf node, then the response will contain values from all leaf nodes in the subtree given by the path. The search filter makes it possible to tailor a subset of this response. The search query has the structure<br>
  <dfn>$path EQ search-expression</dfn><br>
where<br>
  - $path is the reserved word for search filtering.<br>
  - the equal sign (EQ) is the only allowed comparison operator for search filtering.<br>
  - search-expression is a path expression that may contain the wildcard character (*) for representation of an unknown node name.<br><br>
The search-expression is relative to the root node given by the path component in the request. An example could be "*/*/isOpen", which, preceeded with a slash, and concatenated with the request root-path "Vehicle/Cabin/Door" would generate the absolute search expression "Vehicle/Cabin/Door/*/*/isOpen", in which case the response would contain all values from the isOpen nodes in that subtree, but not from the other possible leaf nodes in it.<br><br>
The search filter can be used also in subscribe requests, see chapter Filter combinations.

		</p>
        </section>
       <section data-dfn-for="data-value-filter">
          <h3>Data value filter</h2>
		<p>If a request, typically when it is addressing a subtree, is only interested in response data with a specific value, then a data value filter can be used. 
The data value query has the structure<br>
  <dfn>$data comparison-operator value</dfn><br>
where<br>
  - $data is the reserved word for data value filtering.<br>
  - comparison-operator is one of either the equal sign (EQ), the greater than sign (GT), or the less than sign (LT).<br>
  - value is a number following Javascript syntax rules, or a boolean value.<br><br>
If the data type of the value-expression is different from the data type of the node matching the path, then an error response is returned.
		</p>
        </section>
      </section>
     <section data-dfn-for="subscribe-filter">
        <h3>Subscribe filtering</h2>
		<p>The available subscribe filtering options are presented in the following chapters, and is only applicable to subscribe requests. The filter expression is carried in the request payload in the form of a key-value pair "filter": "filter expression", where "filter" is the key name, and "filter expression" is replaced by the actual expression. 
		</p>
       <section data-dfn-for="interval-filter">
          <h3>Interval filter</h2>
		<p>An interval filter is used in a subscribe request when the client wants subscription notifications to be issued by the server at a regular time interval. 
The interval query has the structure<br>
  <dfn>$interval EQ value</dfn><br>
where<br>
  - $interval is the reserved word for interval filtering.<br>
  - the equal sign (EQ) is the only allowed comparison operator for interval filtering.<br>
  - value is an integer value in milliseconds representing the interval between issued notifications.<br>
		</p>
        </section>
       <section data-dfn-for="range-filter">
          <h3>Range filter</h2>
		<p>A range filter is used when the client wants subscription notifications to be issued by the server when a value enters/exits the defined range.
The range query has the structure<br>
  <dfn>$range comparison-operator value</dfn><br>
where<br>
  - $range is the reserved word for range filtering.<br>
  - comparison-operator is one of either the greater than sign (GT), or the less than sign (LT).<br>
  - value is a number following Javascript syntax rules.<br>
		</p>
        </section>
       <section data-dfn-for="change-filter">
          <h3>Change filter</h2>
		<p>A change filter is used when the client wants subscription notifications to be issued by the server when a value has changed more than a defined value since last notification.
The change query has the structure<br>
  <dfn>$change comparison-operator value</dfn><br>
where<br>
  - $change is the reserved word for change filtering.<br>
  - comparison-operator is one of either the greater than sign (GT), or the not equal sign (NEQ).<br>
  - value is a number following Javascript syntax rules.<br><br>
When using the not equal comparison operator it MUST have the value zero, all other values lead to an error response. The usage is interpreted as "for any change", and also supports boolean changes.
		</p>
        </section>
      </section>
      <section data-dfn-for="filter-combinations">
        <h3>Filter combinations</h2>
		<p>Queries of the types descibed below can be aggregated to form more complex queries. The format for this is then<br>
  <dfn>query1 AND query2 AND .. queryN</dfn><br>
where<br>
  - queryN is any of the query types, following the allowed combinations shown in Table 1.<br>
  - N is maximum four.<br>
  - AND is the logical AND operator.<br>
		</p>
		<p>
		<table border="1">
			<tr><th>Index</th><th>Filter name</th><th>Allowed combinations</th></tr>
			<tr>
				<th>1.</th>
				<td><dfn>Service discovery</dfn></td>
				<td>None</td>
			</tr>
			<tr>
				<th>2.</th>
				<td><dfn>Search</dfn></td>
				<td>3+4+5+6</td>
			</tr>
			<tr>
				<th>3.</th>
				<td><dfn>Data value</dfn></td>
				<td>2</td>
			</tr>
			<tr>
				<th>4.</th>
				<td><dfn>Interval</dfn></td>
				<td>2</td>
			</tr>
			<tr>
				<th>5.</th>
				<td><dfn>Range</dfn></td>
				<td>2+5+6</td>
			</tr>
			<tr>
				<th>6.</th>
				<td><dfn>Change</dfn></td>
				<td>2+5</td>
			</tr>
		</table>
		</p>
              <p>An example of a read request URI containing an aggregated query is<br> 
<dfn>Vehicle/Cabin/Door?$pathEQ*/*/isOpenAND$dataEQfalse</dfn><br> 
which would return data for all locked doors.<br>
In filter combinations where a search expression in the URI is combined with a subscribe filter expression in the payload, the logical AND operator combines them.</p>
<div class="issue">Shall it be possible to use search filtering in subscribe requests?</div>
      </section>
<div class="issue">Other data models may want further query support.Should there be some text about that?</div>
     </section>
 
    <section data-dfn-for="access-control-model">
      <h2>Access control model</h2>
      <div class="issue">We should include some motivation text and maybe reference to Extended Vehicule and other standars where vehicle data is exposed to third parties so justify the need for a solid access control model.</div>
      <p>
      </p>
      <section data-dfn-for="gen2-oauth-architecture">
        <h2>Gen2 OAuth 2.0 architecture</h2>
        <p>
        The Gen2 access control model builds on the concepts of OAuth2.0 [[RFC6749]].<br>
        OAuth2.0 introduces an authorization layer to separate the role of the client from that of the resource owner. The client requests access to resources controlled by the resource owner and hosted by the resource server, and is issued a set of credentials.<br>
        To access protected resources, the client obtains an access token -- a string denoting a specific scope, lifetime, and other access attributes.  Access tokens are issued to clients by an authorization server with the approval of the resource owner. The client uses the access token to access the protected resources hosted by the resource server.<br>
        The abstract OAuth 2.0 flow illustrated in the figure below describes the interaction between the four actors.<br>
        <figure id="fig-oauth2.0-flow">
          <img src="images/oauth2-protocol-flow.jpg" alt="OAuth2.0 abstract protocol flow.">
          <figcaption> <span class="fig-title">OAuth2.0 abstract protocol flow.</span></figcaption>
        </figure>
        Two different flows are supported in Gen2, which both follow the OAuth2.0 abstract flow, as will be described in the chapters below.<br>
        The actor names are however changed as shown in the table below.<br><br>
		<table border="1">
			<tr><th>OAuth2.0 name</th><th>Gen2 name</th></tr>
			<tr>
				<td>Client</td>
				<td>Client</td>
			</tr>
			<tr>
				<td>Resource Owner</td>
				<td>Access Grant server</td>
			</tr>
			<tr>
				<td>Authorization server</td>
				<td>Access Token server</td>
			</tr>
			<tr>
				<td>Resource server</td>
				<td>Gen2 access control server</td>
			</tr>
		</table><br>
	A detailed description of each actor is found in following chapters.
        </p>
      </section>
      <section data-dfn-for="access-control-flows">
        <h2>Access control flows</h2>
        <p>Depending on the capabilities of the client accessing VSS data, two different access control flows are defined. The first protocol flow requires the client to run public key cryptographic primitives, i.e. key pair generation and signatures, and is recommended for clients with access to some kind of trusted exectution environment where private keys are protected from the regular execution environment. The second protocol flow requires no extra capabilities in the client as it is based on OAuth 2.0 Bearer token authentication [[RFC6750]].
        </p>
        <section data-dfn-for="pki-based-flow">
          <h2>PKI based flow</h2>
          <div class="issue">Client needs to include in the JWT a some kind of Proof-of-Possession (RFC7800).</div>
          <div class="issue">The public key became the client identity, we need a mechanisms to register it to the ATG.</div>
          <p>
            Before any interaction with the VSS server, the client needs to be registered in the system. This can be done in several ways, but for this particular flow the process involves three actors: The client device, the client application and the user behind it.
            All of them need to cooperate for a suscesfull client registration. The registration process for the client would be as follows:
          </p>
          <ul>
            <li>The USER installs the APP in the device. User could the OEM if we consider an APP that is preinstalled in the car. It could a third party adding services to the car or it could be the owner/driver itself.</li> 
            <li>The APP generates a key pair. In this step the APP needs to generate a key pair. The private key would be used to authenticate request comming from this APP/Client. In order to very the requests, the public key should be uploaded to the system. If we have a device that support key attestation, the key could be accompanied by a key attestation certificate that would help the system identify the device.</li>
            <li>The USER register the APP to the system. This is the final step for registration. The user needs to confirm to the Authorization Server the public key of the APP and, optionally, restric the permisions granted to the APP. This step can be perfomed in a web interface, where the user authenticates using any standard mechanism. The user will enter a Key ID or the full Key if requested, and the server will match that with the registered APP. If there is a matching, the system will prompt the user for confirmation of the access rights granted to the APP.</li>
          </ul>
          After the registration, USER and APP are bonded, and in case the device suppports some kind of key attestation, the DEVICE can also be bonded to them. The USER can decide to revoke that bond at any time. After revokation the APP is still registered to the system and can be bond to a diferrent user.
          <div class="issue">Does it makes sense to bond an APP to more than one USER at the same time?</div>
          <div class="issue">Who should be in charge of de-registering APPs? Should be set an expiration time for registration? That would for the APP to re-register after some inactivity, limiting grown of inactive registered APPs</div>

          Registered APPs can request access to any signal they were granted access to by the USER at the registration phase. In order to do so, the APP needs to request an Access Token to the Access Token Server indicating the particular target signal or path. In this request, the APPs needs to include also an identifier of is public key and a Proof-of-Possesion of the private key. A JWT signed by the private key of the APP, including the current unix time will serve that purpose.
          <div class="issue">Should we also include purpose here?</div>
          The Access Token Server will first validate the request:
          <ul>
            <li>It needs to check that the Key ID corresponds to a registered APP and recover the correspoding Public Key. If there is not APP registered with this key ID the request will be rejected.</li>
            <li>It will check the JWT digital signature using the public key of the APP. If the digital signature verification fail the request will be rejected.</li>
            <li>It will check the timestamp included in the JWT, in case the timestamp is too old, the request will be denied.</li>
            <div class="issue">Should we define a recomended maximum accepted delay?</div>
            <li>Finally, it will check that the signal/path requested is included in the access rights granted at registration time.</li>
            <div class="issue">That final steps is the most complex, as it has to deal with the access control policy, i.e. RBAC or similar proposals. The other steps are very straightforward. We might need a separate section just for that and omit this in the flows to avoid unnecesary complexity when following them.</div>
          </ul> 

          After successful validation, the APPs recives an Access Token that can be used later on to when querying the VSS Server. 
          <div class="issue">This Access Token can be opaque or in the form of an JWT signed by the Access Token Server that includes access rights granted. Should we recomend one of the two options or leave it open?</div>
          The last phase of the flow is the actual fetching of the signals values. In order to get the signals from the VSS server the APP includes the Access Token in the request headers. The Gen2 access control server will incercept the request and check the Access Token before passing it to the VSS server. If there is not Access Token and security is enable the request is rejected. If the token issued by the Access Token Server was opaque, the Gen2 access control server would need to contact it in each request, in order to obtain the access rights granted. If the token was a JWT, the Gen2 access control server will have all the information required to grant or deny the request. In any case, if the access rights granted match the requested path the request will be send to the VSS server that will send a response to the APP, otherwise the request will be rejected.

          <p>
          <figure id="fig-sequence-diagram-pki-based-flow">
            <img src="images/pki-based-flow.png" alt="Sequence diagram showing a PKI based flow">
            <figcaption> <span class="fig-title">Sequence diagram showing a PKI based flow</span></figcaption>
          </figure>
          </p>
        </section>
        <section data-dfn-for="token-based-flow">
          <h2>Token based flow</h2>
          <p>
          <figure id="fig-sequence-diagram-token-based-flow">
            <img src="images/token-based-flow.jpg" alt="Sequence diagram showing a token based flow">
            <figcaption> <span class="fig-title">Sequence diagram showing a token based flow</span></figcaption>
          </figure>
          </p>
        </section>
        <section data-dfn-for="flow-negotiation">
          <h2>Flow negotiation</h2>
          <p>
          (A solution could be as described. 
          A client can in its request to the AG server either provide a public key, or not.
          If it does, then that signals that the client requests a PKI based flow.
          If it is missing then that signals that the client requests a token based flow.
          The AG server may return an error code if a PKI based flow is requested, but it does not have sufficient trust in the client.
          The AG server may return an error code if a token based flow is requested, but the server requires a PKI based flow.)
          </p>
        </section>
      </section>
      <section data-dfn-for="access-grant-server">
        <h2>Client</h2>
        <p>
<div class="issue">Describe the combi-role model</div>
        </p>
      </section>
      <section data-dfn-for="access-grant-server">
        <h2>Access Grant server</h2>
        <p>
        </p>
        <section data-dfn-for="pki-based-request">
          <h2>PKI based request</h2>
          <p>
          </p>
        </section>
        <section data-dfn-for="token-based-request">
          <h2>Token based request</h2>
          <p>
          </p>
        </section>
      </section>
      <section data-dfn-for="access-token-server"">
        <h2>Access Token server</h2>
        <p>
        </p>
      </section>
      <section data-dfn-for="gen2-access-control-server">
        <h2>Gen2 access control server</h2>
        <p>
        If the Gen2 server implements access control, then it MUST support validation of Access tokens.
        This includes validation of at least the following:
          <ul>
            <li>Token signature.</li>
            <li>Token expiry time.</li>
            <li>Token scope.</li>
            <li>Token access mode.</li>
          </ul>
          If any of the mentioned validations above fail, the server MUST reject the access request.<br>
          Token signature validation may be delegated to the AT server, if a secure communication link can be established.
          If not delegated, then a preprovisioned common secret may be shared with the AT server, or other PKI based solutions may be used.<br>
          The Gen2 server SHALL have access to a secure system time, that cannot be modified by actors withtout system acknowledged credentials. 
          Time validation may allow for a time synchronization error in the range of tens of seconds.<br>
          A successful scope validation requires that all the nodes addressed by the path in the request MUST be matched by the paths in the scope field of the Access token.<br>
          The access mode validation MUST have the outcome shown in the table below, which compares the type of request with the access control mode field in the Access token.<br><br>
<table class="simple">
<thead>
  <tr><th>Validation</th><th>Read-only</th><th>Read-write</th></tr>
</thead>
<tbody>
  <tr>
    <th rowspan="4"><dfn data-dfn-type="dfn" id="dfn-getrequest">get<br>set<br>subscribe</dfn></th>
  </tr>
  <tr><td>Ok</td><td>Ok</td></tr>
  <tr><td>Nok</td><td>Ok</td></tr>  
  <tr><td>Ok</td><td>Ok</td></tr>  
</tbody>
</table>
        </p>
      </section>
      <section data-dfn-for="access-control-selection">
        <h2>Access control selection</h2>
        <p>This chapter describes a complementary functionality to the access control model, the ability to apply it selectively to parts of the tree. 
        It can be used in cases where not all nodes of the tree are believed to require access control, 
        or read-only is sufficient instead of read-write access control for certain nodes.<br>
        This functionality requires that the Access token contains access permission data specifying whether the access to a node is read-only, or read-write.
        It also requires that the metadata for the node in the VSS tree contains data specifying whether the access control verification should be carried out only for write request, 
        or for both read and write requests.<br>
        The former requirement is realized by having a field in the Access token named "acm" specifying the access control mode. 
        This field can either contain the string "read-only", or "read-write". 
        The client request to the Access token server MUST contain either of these string values for every node in the request.<br>
        The latter requirement is realized by adding to nodes in the VSS tree the key-value pair "validate":'access-control-mode', 
        where 'access-control-mode' is either the string "write-only", or "read-write".<br>
        <figure id="fig-access-control-selection">
          <img src="images/access-control-selection.jpg" alt="Access control selection tagging.">
          <figcaption> <span class="fig-title">Access control selection tagging.</span></figcaption>
        </figure>
        The figure above shows an example where both read and write requests to the three leftmost leaf nodes will be access controlled, 
        while the two rightmost leaf nodes only will be access controlled for write requests.<br>
        This metadata is not likely to be applied to the standardised VSS tree, as different users of this standard may have different views on which nodes to apply it to. 
        Instead it is anticipated that it is applied at a "deployment" stage, possibly using the VSS layering concept. 
        To make possible a reduction of the number of nodes this metadata have to be added to, an inheritance model is used. 
        If access-control-mode data is added to a node, then all nodes in the subtree for which this node is the root inherits the setting, 
        unless there is access-control-mode data added to any node in this subtree. 
        In such cases this new access-control-mode setting is inherited by the subtree of this node. 
        This allows for example an entire VSS tree to be assigned an access-control-mode by merely applying it in the root of the tree.<br>
        The figure below shows an overview of the access control selection model, 
        and a table showing the required access control tagging of a node for the Gen2 server to grant the requested access. 
        <figure id="fig-access-control-selection-model">
          <img src="images/access-control-selection-model.jpg" alt="Access control selection model.">
          <figcaption> <span class="fig-title">Access control selection model.</span></figcaption>
        </figure>
        If the VSS tree used by a Gen2 server contains access control selection tags, then the server MUST support their usage as described in this chapter.<br>
        If it is not used, then a server MAY implement access control for the entire tree.<br>
        If access control is implemented, the server MUST support the error codes shown in the table below.<br>
        <table id="errorDefs" class="parameters">
	  <tbody><tr>
	    <th>Error&nbsp;Number&nbsp;(Code)</th>
	    <th>Error Reason</th>
	    <th>Error Message</th>
	  </tr>
	  <tr>
	    <td>404 (Not Found)</td>
	    <td>missing_token</td>
	    <td>The addressed node is access controlled, a token must be included in the request.</td>
	  </tr>
	  <tr>
	    <td>406 (Not Acceptable)</td>
	    <td>invalid_token</td>
	    <td>A new, valid access token must be obtained.</td>
	  </tr>
	  <tr>
	    <td>406 (Not Acceptable)</td>
	    <td>insufficient_priviledges</td>
	    <td>The priviledges represented by the access token are not sufficient.</td>
	  </tr>
	  </tbody>
	</table>
        </p>
      </section>
    </section>
      <h2>Interface</h2>
      <p>
        This chapter describes the different methods and its arguments that govern the communication between a <a>client</a> and the <a>server</a>.
      </p>
      <section data-dfn-for="methods">
        <h2>Methods</h2>
        <p>
          The transport protocols used to implement these methods MUST implement the Read and Update methods, and MAY implement the Subscribe, Unsubscribe, and Subscription methods. 
        </p>
        <section data-dfn-for="read">
          <h2><dfn>Read</dfn></h2>
          <p>Purpose: Get one or more values addressed by the given path.</p>
          <p>The client MAY have to obtain an <a>authorization</a> token before being able to access the values.
             If the server is able to satisfy the request it MUST return a <a>success response</a>.
             If the server is unable to fulfil the request, then the server MUST return an <a>error response</a>.</p>
          <p>Arguments: 
          <ul>
            <li><a>path</a> The path as defined in VSS to one or more nodes in the VSS tree.</li>
            <li><a>filter</a> Additional information defining the requested data.</li>
            <li><a>authorization</a> The authorization token.</li>
          </ul>
          </p>
          <p>Success response:
            <ul>  
              <li><a>value</a> The value(s) associated with the addressed VSS nodes.</li>
              <li><a>timestamp</a> The sample time of the value.</li>
            </ul>
          </p>
        </section>
        <section data-dfn-for="update">
          <h2><dfn>Update</dfn></h2>
          <p>Purpose: Provide altered value to the vehicle signal(s) addressed by the <a>path</a></p>
          <p>The client MAY have to obtain an authorization token before being able to update the vehicle signal(s).  
             If the server is able to satisfy the request it MUST return a <a>success response</a>. 
             If the server is unable to fulfil the request, then the server MUST return an <a>error response</a>.</p>
          <p>Arguments: 
            <ul>
              <li><a>path</a> The path as defined in VSS to one or more nodes in the VSS tree.</li>
              <li><a>value</a> The value by which the vehicls signals addressed by the path will be updated to.</li>
              <li><a>authorization</a> The authorization token.</li>
            </ul>
          </p>
          <p>Success response:
            <ul>  
              <li><a>timestamp</a> The time for updating of the vehicle signals.</li>
            </ul>
          </p>
        </section>
        <section data-dfn-for="subscribe">
          <h2><dfn>Subscribe</dfn></h2>
          <p>Purpose: Get asynchronous messages containing the value(s) addressed by the path. The triggering rules for issuing the notification messages are set by the filter data.</p>
          <p>The client MAY have to obtain an authorization token before being able to subscribe to the vehicle signal(s).
             The server MUST issue a notification if a trigger rule is fulfilled.
             If the server is able to satisfy the request it MUST return a <a>success response</a>.
             If the server is unable to fulfil the request, then the server MUST return an <a>error response</a>.
             If an error occurs during the subscription period, the server SHOULD return an <a>error notification</a>.</p>
          <p>Arguments: 
            <ul>
              <li><a>path</a> The path as defined in VSS to one or more nodes in the VSS tree.</li>
              <li><a>filter</a> The rule set describing triggering criterias for issuance of asynchronous notification messages.</li>
              <li><a>authorization</a> The authorization token.</li>
            </ul>
          </p>
          <p>Success response:
            <ul>  
              <li><a>subscriptionId</a> A handle identifying notification messages associated with the subscription.</li>
              <li><a>timestamp</a> The start time for the subscription period.</li>
            </ul>
          </p>
        </section>
        <section data-dfn-for="unsubscribe">
          <h2><dfn>Unsubscribe</dfn></h2>
          <p>Purpose: Termination of the subscription period started by a previous subscribe request.</p>
          <p>If the server is able to satisfy the request it MUST return a <a>success response</a>, and it MUST stop issuing notifications associated to the subscription handle.
             If the server is unable to fulfil the request, then the server MUST return an <a>error response</a>.</p>
          <p>Arguments: 
            <ul>
              <li><a>subscriptionId</a> Handle identifying the subscription.</li>
            </ul>
          </p>
          <p>Success response:
            <ul>  
              <li><a>subscriptionId</a> Handle identifying the subscription.</li>
              <li><a>timestamp</a> The stop time for the subscription period.</li>
            </ul>
          </p>
        </section>
        <section data-dfn-for="subscription">
          <h2><dfn>Subscription</dfn></h2>
          <p>Purpose: Asynchronous client notification according to the subscribe request trigger rules.</p>
          <p>The server MUST issue a notification message when a triggering rule associated with the subscription is met.
             If the server cannot fulfill the triggering rules it MUST issue an error notification and terminate the subscription. 
          </p>
          <p>Arguments: 
            <ul>
              <li><a>subscriptionId</a> Handle identifying the subscription.</li>
              <li><a>value</a> The value(s) associated with the node(s) being addressed in the subscribe request.</li>
              <li><a>timestamp</a> The time for the trigger activation.</li>
            </ul>
          </p>
        </section>
      </section>
      <section data-dfn-for="error-information">
        <h2>Error information</h2>
        <p>The server MUST inform a client about errors ocurring in interactions between the two, whether it is in a synchronous <a>error response</a> to a request message, or an asynchronous <a>error notification</a> message.
        </p>
        <section data-dfn-for="error-format">
          <h2>Error format</h2>
          <p>The error information has three components - a <a>number</a>, a <a>reason</a>, and a <a>message</a>. The number MUST always be part of the error information, 
             while the reason and message components MAY be a part of it.
            <ul>
              <li><dfn data-dfn-type="dfn" id="dfn-error-number">number</dfn> See Gen2:TRANSPORT, "Status code" chapter.</li>
              <li><dfn data-dfn-type="dfn" id="dfn-error-reason">reason</dfn> See Gen2:TRANSPORT, "Status code" chapter.</li>
              <li><dfn data-dfn-type="dfn" id="dfn-error-message">message</dfn> See Gen2:TRANSPORT, "Status code" chapter.</li>
            </ul>
          </p>
          </section>
      </section>
      <section data-dfn-for="security">
        <h2>Security</h2>
        <p>
        </p>
      </section>
      <section data-dfn-for="timestamp">
        <h2>Timestamps</h2>
        <p>
           Timestamps in transport payloads MUST conform to the ISO8601 standard, using the UTC format with a trailing Z. 
           Time resolution SHALL at least be seconds, with subsecond resolution as an optional degree of precision when desired.
           The time and date format shall be as shown below, where the sub-second data and delimiter is optional.<br>
           YYYY-MM-DDTHH:MM:SS.ssssssZ<br>
           The exception to this is timestamps within tokens, which MUST conform to Unix time. 
        </p>
      </section>
        <section id="definitions">
          <h2>Definitions</h2>
	<p></p>

	<dl title="enum Defs" class="idl">
	  <dt><dfn data-dfn-type="dfn" id="dfn-client">client</dfn></dt>
	  <dd>An entity that works with data managed by a server.</dd>
	  <dt><dfn data-dfn-type="dfn" id="dfn-server">server</dfn></dt>
	  <dd>An entity that manages and offers access to data.</dd>
          <dt><dfn data-dfn-type="dfn" id="dfn-success-response">success response</dfn></dt>
          <dd>The message being returned by the server to the client when no error is encountered. These are specific per request type</dd>
	  <dt><dfn data-dfn-type="dfn" id="dfn-error-response">error response</dfn></dt>
	  <dd>The message being returned by the server to the client when an error is encountered. These have a common format for all request types</dd>
	  <dt><dfn data-dfn-type="dfn" id="dfn-error-notification">error notification</dfn></dt>
	  <dd>The asynchronous message being returned by the server to the client when an error is encountered.</dd>
	  <dt><dfn data-dfn-type="dfn" id="dfn-value">value</dfn></dt>
	  <dd>The data that is associated with one or more VSS nodes. Regardless of its data type, a single data item is always represented as a string in message payloads.</dd>
          <dt><dfn data-dfn-type="dfn" id="dfn-timestamp">timestamp</dfn></dt>
          <dd>A date and time representation. See chapter "Timestamps".</dd>
	  <dt><dfn data-dfn-type="dfn" id="dfn-filter">filter</dfn></dt>
	  <dd>Additional to help the server in the selection of data for the client.</dd>
	  <dt><dfn data-dfn-type="dfn" id="dfn-query">query</dfn></dt>
	  <dd>A filter may consist of multiple query expressions.</dd>
	  <dt><dfn data-dfn-type="dfn" id="dfn-authorization">authorization</dfn></dt>
	  <dd>A token providing a verifiable proof that the client may be authorized access to the requested value(s).</dd>
	  <dt><dfn data-dfn-type="dfn" id="dfn-subscription-id">subscriptionId</dfn></dt>
	  <dd>A handle identifying a subscription session.</dd>
	</dl>
      </section>
    </section>
    <section id="dynamic-registry-api" class="appendix">
      <h4>Dynamic registry API</h4>
      <p>The dynamic reqistry API provides the functionality to dynamically add or delete branches of the VSS tree. A branch can only be deleted if it has been dynamically added. In the following an entity requesting dynamic registry services is called a "service manager", and the entity performing these requests is called the "core server", see the figure "Gen2 server reference architecure".</p>
    </section>


    <section id="issue-summary" class="appendix"></section>
    <section id="tof" class="appendix"></section>
  </body>
</html>
