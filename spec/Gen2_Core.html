<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <title>Gen2 - Core</title>
    <script 
      src='https://www.w3.org/Tools/respec/respec-w3c-common' 
      class='remove'></script>
    <script type="text/javascript" src="plantuml/jquery.js"></script>
    <script type="text/javascript" src="plantuml/jquery_plantuml.js"></script>
    <script type="text/javascript" src="plantuml/rawdeflate.js"></script>	 
    <script class='remove'>
      var respecConfig = {
        specStatus: "ED",
        editors: [{
          name: "Ulf Bjorkengren",
          company: "Geotab",
          companyURL: "https://www.geotab.com"
        },
        {
          name: "Ulf Bjorkengren",
          company: "Volvo Cars",
          companyURL: "https://www.volvocars.com/intl"
        },
        {
          name: "Isaac Agudo",
          company: "NICS Lab / University of Malaga",
          companyURL: "https://www.nics.uma.es"
        },
                {
          name: "Patrick LÃ¼nnemann",
          company: "Volkswagen Group",
          companyURL: "https://www.volkswagenag.com",
          w3cid: 95844
        }],
        edDraftURI: "https://github.com/w3c/automotive/blob/gh-pages/spec/Gen2_Core.html",
        shortName: "Gen2-CORE",
        localBiblio: {
          "SemVer": {
            title: "Semantic Versioning 2.0.0",
            href: "https://semver.org/spec/v2.0.0.html",
            status: "published",
            publisher: "Tom Preston-Werner"
          }
        }
      };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        This document, the Gen2 core specification, describes the Gen2 messaging layer. 
        The companion specifications for the Gen2 transport protocols detail the mapping of the messaging layer to selected transports.
        The ontologies based on the Gen2 core specification are defined in documents for each specific domain
        (e.g. navigation, media, vehicle data). 
      </p>
    </section>
    <section id='sotd'></section>

    <section id="introduction">
      <h2>Introduction</h2>
      <p>
        This document describes the messaging API for Gen2 protocol. 
        This includes the messaging layer and set of rules for structuring data.
        The separation between payload encoding (transport) and messaging API (core) improves adaptability. 
        Extending and describing multiple transport protocols becomes possible.
      </p>     
      <p>
        The messages are exchanged between a <a>server</a> implementation holding the representation of data 
        and a <a>client</a> using the data.
      </p>
      <p>
        The Gen2 messaging layer uses a RESTful design for all methods exchanged via the interface (<a href="#interface"></a>).
      </p>
      <p>
        The Gen2 data structuring rules (<a href="http://genivi.github.io/vehicle_signal_specification/">VSS Rule set</a>) are the same through all transport protocols.
        The basis for structuring data hold by a <a>server</a> is a tree.
      </p>
    </section>

    <section id="conformance"></section>
    <section id="terms">
      <h2>Terminology</h2>
      <p>The acronym 'Gen2' is used to refer to this document, the second generation specification. The acronym 'VSS' is used to refer to the 'Vehicle Signal Specification' which is defined by the GENIVI Alliance. The term 'WebSocket' when used in this document, is as defined in the W3C WebSocket API and the WebSocket Protocol.</p>
    </section>
    <section data-dfn-for="data-model">
      <h2>Data model</h2>
		<p>

The service is intended for use with a tree-like logical taxonomy to
represent the vehicle data. An illustrative example of such a tree
structure is shown in <a href="#fig-example-vss-tree">Figure 1</a>. While it
is meant to support conforming taxonomies it was created principally
with the <a href="https://github.com/GENIVI/vehicle_signal_specification">Vehicle Signal Specification</a> (VSS) in mind. For more
details, see the <a href="http://genivi.github.io/vehicle_signal_specification/">VSS documentation</a>.
		</p>
        <figure id="fig-example-vss-tree">
          <img src="images/vss-tree.jpg" alt="example-vss-tree">
          <figcaption> <span class="fig-title">Diagram showing an example VSS 2.0 tree.</span></figcaption>
        </figure>

      <section data-dfn-for="address">
        <h2>Addressing</h2>
        <p>Addressing of elements is done using URIs as defined in [[RFC3986]].</p>
        <blockquote><a>scheme</a>:<a>authority</a>/<a>path</a>?<a>query</a></blockquote>
        <p>The <dfn>scheme</dfn> describes the protocol to use to reach the addressed element.</p>
        <p>The <dfn>authority</dfn> describes where to reach the server holding and managing the data representation.
          Scheme and authority are defined within the protocol adaptation.</p>
        <p>The <dfn>path</dfn> consists of the slash delimited node names of the nodes traversed from the tree root to the tree leaf representing the data point. E. g. the path expression from traversing the nodes Vehicle, Car, Engine, RPM would be "Vehicle/Car/Engine/RPM". The VSS data model uses a dot as delimiter, the implementaion of this specification is expected to handle the necessary translation.</p>
        <p>The <a>query</a> contains further information related to the request, see <a href="#filtering"></a>.
      </section>
        <section id="service-discovery">
          <h2>Service discovery</h2>
          <p>The purpose of the data model is to provide a client with a description of the data that enables the client to make a request for desired vehicle data, and interpret the response. In order to obtain that description, the client MAY request that the server returns the VSS tree content, i. e. the metadata describing the accessible vehicle data. The client is able to request metadata from any point in the signal tree, such that only the metadata for the nodes within the given branch of the tree is returned. For example, only metadata for the chassis branch of the VSS tree is returned when the chassis path is specified. If the path is set to the VSS root, the response contains the metadata for the entire tree. If the server is able to satisfy the request it SHALL return a Response message. If an error occurs the server SHALL return an ErrorResponse message.<br>A service discovery request has the format of a read, where the path is appended with a query component, see <a href="#service-discovery-filter"></a> for the details.<br>The key data components of these messagess are defined below:</p>
          <ul>  
            <li>Request message parameters:</li>
            <ul>  
              <li>Path: The address to one or more nodes in the VSS tree, followed by the query component specifying the service discovery.</li>
            </ul>  
            <li>Response message parameters:</li>
            <ul>  
              <li>Metadata: The content of the VSS tree where the root is specified by the path.</li>
              <li>Timestamp: A timestamp associated with the request.</li>
            </ul>  
            <li>ErrorResponse message parameters: </li>
            <ul>  
              <li>Error: Information describing the error reason.</li>
              <li>Timestamp: A timestamp associated with the failed request.</li>
            </ul>  
          </ul>  
        <section id="dynamic-registry">
          <h2>Dynamic registry</h2>
          <p>To enable e. g. after-market services it SHALL be possible to dynamically add new branches to the VSS tree, and if requested also to delete them at a later point.<br>Requests of this type are not expected to be frequent for the type of data that is represented in the "vehicle signal domain", which is the current scope of VSS. These requests are therefore partitioned in a separate API, which is described in "Appendix: Dynamic registry API". </p>
        </section>
        </section>
    </section>
	
    <section id="filtering">
      <h2>Filtering</h2>
	  <p>Filtering is a mechanism to refine a client request, in order to more precisely control the data in a response. Filtering can be applied in read requests and in subscribe requests.For read requests the filter expression MUST be appended to the request path in the form of a <a>query</a> component following the description in [[RFC3986]]. For subscribe requests the filter expression MUST be carried in the request payload. The filter expression follows the same general rules in both request cases. The query component must have the following structure<br>
  <dfn>reserved-word comparison-operator expression</dfn><br>
where<br>
  - reserved-word must have the dollar-sign as the first character ($). The availabe reserved words are described in the chapters below.<br>
  - comparison-operator is one of either the equal sign (EQ), the greater than sign (GT), or the less than sign (LT).<br>
  - expression is a character string with its interpretation given by the preceeding reserved-word and comparison operator.<br><br>
Filter expressions can consist of multiple query expressions, as described in <a href="#filter-combinations"></a>.<br><br>
As filtering is implemented on the server side, in vehicles, the filtering complexity is intentionally kept to a low level in order to not load the processing resources too much.
	  </p> 
     <section data-dfn-for="read-filter">
        <h3>Read filtering</h2>
		<p>The available read filtering options are presented in the following chapters, and are only applicable to read requests. As described in [[RFC3986]], a question mark must be inserted as a delimiter between the path and the query components.
		</p>
       <section data-dfn-for="service-discovery-filter">
          <h3>Service discovery filter</h2>
		<p>The service discovery query has the structure<br>
  <dfn>$spec EQ depth</dfn><br>
where<br>
  - $spec is the reserved word for service discovery filtering.<br>
  - the equal sign (EQ) is the only allowed comparison operator for service discovery filtering.<br>
  - depth sets the maximum branch depth that is returned in the response, counted from the root node given by the path component in the request.
Depth MUST be a positive integer. If set to zero, it is replaced by the max depth of the subtree.
		</p>
        </section>
       <section data-dfn-for="search-filter">
          <h3>Search filter</h2>
		<p>If the path in a read request does not terminate in a leaf node, then the response will contain values from all leaf nodes in the subtree given by the path. The search filter makes it possible to tailor a subset of this response. The search query has the structure<br>
  <dfn>$path EQ search-expression</dfn><br>
where<br>
  - $path is the reserved word for search filtering.<br>
  - the equal sign (EQ) is the only allowed comparison operator for search filtering.<br>
  - search-expression is a path expression that may contain the wildcard character (*) for representation of an unknown node name.<br><br>
The search-expression is relative to the root node given by the path component in the request. An example could be "*/*/isOpen", which, preceeded with a slash, and concatenated with the request root-path "Vehicle/Cabin/Door" would generate the absolute search expression "Vehicle/Cabin/Door/*/*/isOpen", in which case the response would contain all values from the isOpen nodes in that subtree, but not from the other possible leaf nodes in it.<br><br>
The search filter can be used also in subscribe requests, see chapter Filter combinations.<br>
The response message on a request addressing multiple signals contains all the matching signal values. Notifications from a subscription addressing multiple signals contain one signal value per notification.
		</p>
        </section>

       <section data-dfn-for="data-value-filter">
          <h3>Data value filter</h2>
		<p>If a request, typically when it is addressing a subtree, is only interested in response data with a specific value, then a data value filter can be used. 
The data value query has the structure<br>
  <dfn>$data comparison-operator value</dfn><br>
where<br>
  - $data is the reserved word for data value filtering.<br>
  - comparison-operator is one of either the equal sign (EQ), the greater than sign (GT), or the less than sign (LT).<br>
  - value is a number following Javascript syntax rules, or a boolean value.<br><br>
If the data type of the value-expression is different from the data type of the node matching the path, then an error response is returned.
		</p>
        </section>
      </section>
     <section data-dfn-for="subscribe-filter">
        <h3>Subscribe filtering</h2>
		<p>The available subscribe filtering options are presented in the following chapters, and is only applicable to subscribe requests. The filter expression is carried in the request payload in the form of a key-value pair "filter": "filter expression", where "filter" is the key name, and "filter expression" is replaced by the actual expression. 
		</p>
       <section data-dfn-for="interval-filter">
          <h3>Interval filter</h2>
		<p>An interval filter is used in a subscribe request when the client wants subscription notifications to be issued by the server at a regular time interval. 
The interval query has the structure<br>
  <dfn>$interval EQ value</dfn><br>
where<br>
  - $interval is the reserved word for interval filtering.<br>
  - the equal sign (EQ) is the only allowed comparison operator for interval filtering.<br>
  - value is an integer value in milliseconds representing the interval between issued notifications.<br>
		</p>
        </section>
       <section data-dfn-for="range-filter">
          <h3>Range filter</h2>
		<p>A range filter is used when the client wants subscription notifications to be issued by the server when a value enters/exits the defined range.
The range query has the structure<br>
  <dfn>$range comparison-operator value</dfn><br>
where<br>
  - $range is the reserved word for range filtering.<br>
  - comparison-operator is one of either the greater than sign (GT), or the less than sign (LT).<br>
  - value is a number following Javascript syntax rules.<br>
		</p>
        </section>
       <section data-dfn-for="change-filter">
          <h3>Change filter</h2>
		<p>A change filter is used when the client wants subscription notifications to be issued by the server when a value has changed more than a defined value since last notification.
The change query has the structure<br>
  <dfn>$change comparison-operator value</dfn><br>
where<br>
  - $change is the reserved word for change filtering.<br>
  - comparison-operator is one of either the greater than sign (GT), or the not equal sign (NEQ).<br>
  - value is a number following Javascript syntax rules.<br><br>
When using the not equal comparison operator it MUST have the value zero, all other values lead to an error response. The usage is interpreted as "for any change", and also supports boolean changes.
		</p>
        </section>
      </section>
      <section data-dfn-for="filter-combinations">
        <h3>Filter combinations</h2>
		<p>Queries of the types descibed below can be aggregated to form more complex queries. The format for this is then<br>
  <dfn>query1 AND query2 AND .. queryN</dfn><br>
where<br>
  - queryN is any of the query types, following the allowed combinations shown in Table 1.<br>
  - N is maximum four.<br>
  - AND is the logical AND operator.<br>
		</p>
		<p>
		<table border="1">
			<tr><th>Index</th><th>Filter name</th><th>Allowed combinations</th></tr>
			<tr>
				<th>1.</th>
				<td><dfn>Service discovery</dfn></td>
				<td>None</td>
			</tr>
			<tr>
				<th>2.</th>
				<td><dfn>Search</dfn></td>
				<td>3+4+5+6</td>
			</tr>
			<tr>
				<th>3.</th>
				<td><dfn>Data value</dfn></td>
				<td>2</td>
			</tr>
			<tr>
				<th>4.</th>
				<td><dfn>Interval</dfn></td>
				<td>2</td>
			</tr>
			<tr>
				<th>5.</th>
				<td><dfn>Range</dfn></td>
				<td>2+5+6</td>
			</tr>
			<tr>
				<th>6.</th>
				<td><dfn>Change</dfn></td>
				<td>2+5</td>
			</tr>
		</table>
		</p>
              <p>An example of a read request URI containing an aggregated query is<br> 
<dfn>Vehicle/Cabin/Door?$pathEQ*/*/isOpenAND$dataEQfalse</dfn><br> 
which would return data for all locked doors.<br>
In filter combinations where a search expression in the URI is combined with a subscribe filter expression in the payload, the logical AND operator combines them.</p>
      </section>
     </section>
 
    <section data-dfn-for="access-control-model">
      <h2>Access control model</h2>
      <p>
      Access control MUST be supported. However, in this chapter only the sections that describe the interactions between the Client and the Gen2 server are normative.
      </p>

      <section data-dfn-for="architecture">
        <h2>Architecture</h2>
        <p>
        <em>This section is non-normative.</em><br>
        The Gen2 access control model is inspired by the concepts of OAuth2.0 [[RFC6749]], but some deviations exist as is described in the following chapters.<br><br>
        Four actors are defined:<br>
        <b>Client</b><br>
        An application making protected resource requests on behalf of the User and with its authorization.<br>
        <b>Access Grant server</b><br>
        The server issuing the Access Grant credential after successfully authenticating the Client.<br>
        <b>Access Token server</b><br>
        The server issuing the Access Token to the Client after successfully validating the request and obtaining authorization.<br>
        <b>Gen2 server</b><br>
        The server hosting the protected resources, capable of accepting and responding to protected resource requests using Access Tokens.<br><br>
        The abstract protocol flow illustrated in the figure below describes the interaction between the four actors.<br>
        <figure id="fig-oauth2.0-flow">
          <img src="images/gen2-abstract-flow.jpg" alt="Gen2 abstract protocol flow.">
          <figcaption> <span class="fig-title">The abstract protocol flow.</span></figcaption>
        </figure>
        Besides the four actors directly involved in the abstract flow, there are two more actors.<br>
        <b>Resource owner</b><br>
        This is typically the driver of the vehicle, who may be asked for consent before access is granted.<br>
        <b>Ecosystem manager</b><br>
        The entity managing the access control ecosystem. It controls the Policy documents, and manages the PKI ecosystem that the other actors may utilize.<br><br>
        The abstract protocol flow is implemented by two different flows, as will be described in the following chapters.<br>
        The process to obtain the credentials needed for Client authentication is out-of-scope, as well as the installation procedures for the applications.
        </p>
      </section>

      <section data-dfn-for="access-control-flows">
        <h2>Protocol flows</h2>
        <p>
        <em>This section is non-normative.</em><br>
        Two different flows are described. Which flow to use depends on the capabilities of the Client.<br>If a Client is able to run public key cryptographic primitives, 
        i.e. key pair generation and signatures, and has access to some kind of trusted execution environment where private keys are protected from the regular execution environment, 
        then it can use the Long term flow. Clients that do not have access to these capabilities, or do not want to use them, must select the Short term flow.<br>
        The advantage of using the Long term flow is that the Client does not have to contact the AGS when it needs a new Grant token, as it can self issue a new. 
        In the Short term flow the Client must contact the AGS every time it needs a new Grant token.<br>
        A Client selects the type of flow by either submitting a public key in the AG message, or not. The latter leading to an Short term flow.
        </p>
      </section>

      <section data-dfn-for="protocol-messages">
        <h2>Protocol messages</h2>
        <em>This section is non-normative.</em><br>
        This chapter describes the payloads of the messages used in the protocol flow.

        <section data-dfn-for="authorization-grant-request">
          <h2>Access Grant request</h2>
          <p>
          The request shall contain the first two parameters below, the others are optional:
          <ul>
            <li>VIN: The vehicle identification number of the vehicle the Client wants to have access to.</li>
            <li>Context: The context associated to the Client. The context consists of a triplet of roles for User, App permissions, and Device characteristics.</li>
            <li>Proof: A proof mechanism that is used by the Client to attest its context to the AG server. This is indeed a composed proof for the User role, App permissions, and Device characteristics. If a public key is included in the request, the proof parameter will also include of proof of possession for this key.</li>
            <li>Public key: If this parameter is present, the request shall contain a public key of a key pair generated and owned by the Client, and the Proof parameter shall include a proof of possession.</li>
          </ul> 
          </p>
          <p>
            Depending on the kind of Proofs included in the request, the client and the server may need to run an interactive protocol to verify them. This protocol may involve also third parties, such as the Ecosystem manager or the resource owner. 
          </p>
        </section>

        

<section data-dfn-for="authorization-grant-response">
          <h2>Access Grant response</h2>
          <p>
          The response shall contain the first parameter below, the other is optional:
          <ul>
            <li>AG token: A signed token with claims needed for the validation of the Client request.</li>
            <li>Proof: A proof of possession of the Client public key.</li>
          </ul> 
          The response for a successful access grant request is a Short term Access Grant token.  This can be used as direct input to the Access Token server, or its claims can be used to create a Long term Access Grant token for Clients that prefer that option, and have the capability to do so.<br>
          If the request contained a public key, then the AGS shall create an object that the Client can use as a proof of that it is the owner of the public key. 
          This is done by creating a digital signature for the public key, signed by the AGS private key.<br>
          The Access Grant token is a digitally signed document issued by the AG Server including all relevant information needed to issue Access Tokens.
        </p>
        <p>
          An error response shall contain the following parameters:
          <ul>
            <li>Error code: The error code shall be informative in order for the Client to understand what it needs to correct to become successful.</li>
          </ul> 
        </p>

        </section>


        <section data-dfn-for="access-token-request">
          <h2>Access Token request</h2>
          <p>
          The request shall contain the first two parameters below, the other is optional:
          <ul>
            <li>AG token: A signed token with claims needed for the validation of the Client request.</li>
            <li>Purpose: The Purpose shall be one of the short text entries from the Purpose list.</li>
            <li>Proof: A proof of possession of the public key in the AG token.</li>
          </ul> 
            All access token request should include an AG token. Moreover, if the Access Grant token includes a public key, the Client should also include in the request a fresh proof of possession for this public key.
          </p>
          <p>
            Apart from the AG Token, the request should include the short name of a Purpose found on the Purpose list owned by the Ecosystem manager.
          </p>
          <p>
            The Access Token server acts as a Policy Enforcement Point, making decisions on whether to grant access to the protected resource based on the provided AG Token and Purpose.
          </p>

        </section>

        <section data-dfn-for="access-token-response">
          <h2>Access Token response</h2>
          <p>
          A successful response shall contain the following parameters:
          <ul>
            <li>Access token: The Access token to be used in Client requests to the Gen2 server for Protected Resources.</li>
          </ul> 
          An error response shall contain the following parameters:
          <ul>
            <li>Error code: The error code shall be informative in order for the Client to understand what it needs to correct to become successful.</li>
          </ul> 
          </p>
        </section>

        <section data-dfn-for="protected-resource-request">
          <h2>Protected Resource request</h2>
          <p>
          This is the Gen2 request including an Access token that is described in general in the Interface chapter, and for different transport protocols in the Gen2 CORE document.
          </p>
        </section>

        <section data-dfn-for="protected-resource-response">
          <h2>Protected Resource response</h2>
          <p>
          This is the Gen2 response that is described in general in the Interface chapter, and for different transport protocols in the Gen2 CORE document.
          </p>
        </section>
      </section>

      <section data-dfn-for="actors">
        <h2>Actors</h2>

      <section data-dfn-for="client">
        <h2>Client</h2>
        <p>
        <em>This section is non-normative.</em><br>
          The Client is an abstract representation of three sub-actors: 
          <ul>
            <li>The Device. It is in charge of running the Apps that make requests to the Gen2 server</li>
            <li>The App. It runs requests on behalf of the User.</li>
            <li>The User. Delegated access rights to the App.</li>
          </ul> 
          All the information regarding the client is encoded in the Context of the request.
        </p>
      </section>

      <section data-dfn-for="access-grant-server">
        <h2>Access Grant server</h2>
        <p>
        <em>This section is non-normative.</em><br>
          The Access Grant server (AGS) is in charge of producing Access Grants to Clients.<br>
          Depending on the capabilities of the Client, the specification supports two types of Access Grant Tokens: Short term and Long term AG Tokens.<br>
          Long term Access Grant Tokens, are supported for those Clients able to run public key cryptographic primitives, i.e. key pair generation and signatures, 
          and is the recommended choice for Clients with access to some kind of trusted execution environment where private keys are protected from the regular execution environment. 
          The Client must create and sign the Long term AG token, which must contain the public key that corresponds to the private key used by the Client to sign the AG token.<br>
          The specification also supports Short term Access Grant Tokens that require no extra capabilities in the client, 
          but due to its shorter expiry time it forces the client to contact the AGS more often before ATS requests for an Access Token.<br>
          The Client request shall contain the following:
          <ul>
            <li>A VIN.</li>
            <li>A Context.</li>
            <li>A set of Proofs.</li>
          </ul> 
          If the Client needs a Long term AG token, then the request shall also contain:
          <ul>
            <li>A public key.</li>
          </ul> 
          The Vehicle identification number shall be for the vehicle that the Client wants to access.<br>
          The Context contains all relevant information from the client, i.e. for each of the three sub-actors that the Client represents.<br>
          The Proofs are to be used for verifying the Context of the Client.<br>
          The public key shall be generated by the Client, and the associated private key must be under control of the Client.<br><br>
        The main responsibilities of the Access Grant server are:
          <ul>
            <li>To verify the Client Context, and assess that their respective role request can be granted.</li>
            <li>To check that the vehicle represented by the VIN belong to this Ecosystem, and is accessible.</li>
            <li>To create an Access Grant.</li>
          </ul>
          The proofs may include certificates from a Certificate Authority known by the AG server. The AG server shall validate the certificate signature, 
          and utilize certificate information to assess that the requested role can be granted.<br>
          The AG server may contact the Ecosystem manager for checking the VIN.<br>
          The Access Grant generation is defined in the corresponding chapter.
        </p>
          </p>
        </section>

      <section data-dfn-for="access-token-server">
        <h2>Access Token server</h2>
        <p>
        <em>This section is non-normative.</em><br>
        The Client shall after a successful interaction with the AG server request an Access token from the Access Token server. 
        The Client input in that request must be:
          <ul>
            <li>An Access Grant token.</li>
            <li>A Purpose.</li>
          </ul>
        Optionally, for Long term Access Grant tokens, i.e. those including a public key, the Client must also include in the request a fresh proof of possession.<br>
        The Purpose must be supported by the Ecosystem manager, and thus be on the Purpose list, see the chapter Purpose list. 
        The Purpose list associates a set of accessible signals to the Purpose, thus realizing the principle of least priviledge.<br>
        The main responsibilities of the Access Token server are:
          <ul>
            <li>To validate the Access Grant token.</li>
            <li>To validate that the Client context provides permission for the requested Purpose.</li>
            <li>To create an Access Token.</li>
          </ul>
        The validation of the AG token consists of at least the following:
          <ul>
            <li>Signature validation.</li>
            <li>Expiry time check.</li>
          </ul>
        Additionally, when the token contains a public key, i.e. Long term Access Grant tokens, the Access Token server needs to verify that there is a valid and fresh proof of possession for this public key. <br>
        The Short term AG token signature validation is done with the AG server public key, for a Long term AG token it is done with the public key contained in the token. 
        In the latter case also the proof of the Client possession of the public key must be validated.<br>
        The expiry time must be later than the current system time of the AT server run-time. To allow for some time synchronization inaccuracy an error of tens of seconds may be allowed.<br>
        If the Client context as declared in the AG token does not match in the set of allowed roles for the requested Purpose in the Purpose list document, 
        then the client request for an Access token must be denied.<br>
        The Access token to be generated is defined in the chapter Access token.
        </p>
      </section>

      <section data-dfn-for="gen2-access-control-server">
        <h2>Gen2 access control server</h2>
        <p>
        The Gen2 server MUST support validation of Access tokens.
        This includes validation of at least the following:
          <ul>
            <li>Token signature.</li>
            <li>Token expiry time.</li>
            <li>Token scope.</li>
            <li>Token access mode.</li>
          </ul>
          If any of the mentioned validations above fail, the server MUST reject the access request.<br>
          Token signature validation may be delegated to the AT server, if a secure communication link can be established.
          If not delegated, then a preprovisioned common secret may be shared with the AT server, or other PKI based solutions may be used.<br>
          The Gen2 server SHALL have access to a secure system time, that cannot be modified by actors without system acknowledged credentials. 
          Time validation may allow for a time synchronization inaccuracy in the range of tens of seconds.<br>
          A successful scope validation requires that all the nodes addressed by the path in the request MUST be matched by the paths associated to the Purpose in the scope claim of the Access token.<br>
          Validation of the Device and App roles may involve MAC address checks, message round-trip measurements, etc.<br>
          The access mode validation MUST have the outcome shown in the table below, 
          when comparing the type of the Client request with the access control mode in the Purpose list that is associated to the scope claim in the Access token.
          If the Client request contains several signals, and one fails the validation, then the entire request MUST be rejected.<br><br>
          <table class="simple">
          <thead>
            <tr><th>Validation</th><th>Read-only</th><th>Read-write</th></tr>
          </thead>
          <tbody>
            <tr>
              <th rowspan="4"><dfn data-dfn-type="dfn" id="dfn-getrequest">get<br>set<br>subscribe</dfn></th>
            </tr>
            <tr><td>Ok</td><td>Ok</td></tr>
            <tr><td>Nok</td><td>Ok</td></tr>  
            <tr><td>Ok</td><td>Ok</td></tr>  
          </tbody>
          </table>
        </p>
        <p>
          The Access Token need to be refreshed periodically, which is controlled by the expiry time. If the AG token that the Client used to obtain the now expired token is not expired, 
          then the Client can revisit the AT server with this AG token to obtain a new Access token.<br>
          If the AG token is expired, then the Client must obtain a new AG token first, before revisiting the AT server. 
          The process for this depends on whether the Client has the capability to self sign AG tokens ,
          in which case it can generate the new AG token itself, given that the expiry time for this has not expired.<br>
        For Client requests that are not granted due to access control, the Gen2 server MUST return one of the error codes shown in the table below.<br>
        <table id="errorDefs" class="parameters">
	  <tbody><tr>
	    <th>Error&nbsp;Number&nbsp;(Code)</th>
	    <th>Error Reason</th>
	    <th>Error Message</th>
	  </tr>
	  <tr>
	    <td>404 (Not Found)</td>
	    <td>missing_token</td>
	    <td>One or more of the requested signals are access controlled, an access token must be included in the request.</td>
	  </tr>
	  <tr>
	    <td>406 (Not Acceptable)</td>
	    <td>invalid_token</td>
	    <td>A fresh access token must be obtained.</td>
	  </tr>
	  <tr>
	    <td>406 (Not Acceptable)</td>
	    <td>insufficient_priviledges</td>
	    <td>The priviledges represented by the access token are not sufficient.</td>
	  </tr>
	  </tbody>
	</table>
        </p>
      </section>

      <section data-dfn-for="resource-owner">
        <h2>Resource owner</h2>
        <p>
        <em>This section is non-normative.</em><br>
        The Resource owner is typically the owner and/or driver of the vehicle. If Consent is required for granting access to the protected resource, 
        then it should be directed to the Resource owner.
        </p>
      </section>

      <section data-dfn-for="ecosystem-manager">
        <h2>Ecosystem manager</h2>
        <p>
        <em>This section is non-normative.</em><br>
        The Ecosystem manager is the entity responsible for the functionality of the access control system. This typically includes the management of the Access Grant server, 
        and the Access Token server, the Policy documents, and that there is a PKI domain for the other actors to utilize. 
        </p>
      </section>
      </section>

      <section data-dfn-for="credentials">
        <h2>Credentials</h2>
        <p>
        </p>

        <section data-dfn-for="client-authentication">
          <h2>Client authentication</h2>
          <p>
          <em>This section is non-normative.</em><br>
          The three Client sub-actors must provide authentication credentials to the AG server. 
          This may be certificates that the sub-actors have obtained from a Certificate Authority that is known by the AG server. 
          The interactions related to this is out of scope.
          </p>
        </section>

        <section data-dfn-for="authorization-grant-token">
          <h2>Access Grant Token</h2>
          <p>
          <em>This section is non-normative.</em>
          </p>

          <section data-dfn-for="client-signed-agtoken">
            <h2>Long term AG Token</h2>
            <p>
          The Long term Access Grant token shall have the following claims in header and payload.<br>
	  <pre class="highlight hljs javascript" aria-busy="false"><span class="hljs-function"></span>          
	  {
            "alg": "HS256",
            "typ": "JWT"
          },
          {
            "iat": 1609452095,
            "exp": 1609459199,
            "clx": "user+app+dev",
            "pub": client_pub_key
            "sig": digital_signature
            "aud": "w3.org/gen2",
            "jti": "5967e92e-40e8-5f39-892d-cc0da890db1d"
          }
	  </pre>
	  Algorithm (alg) shall be set to "HS256".<br>
	  Type (typ) shall be set to "JWT".<br>
          Issued at (iat) shall be set to the time of token issuance, in Unix time.<br>
          Expiry (exp) shall be set to the time when the token expires, in Unix time.<br>
          Client context (clx) shall be set to the role triplet the client has been assigned. The delimiter separating the roles is a plus sign (+).<br>
          Public key (pub) shall be set to the binary public key that the Client provided in the AG request.<br>
          Digital signature (sig) shall be set to the digital signature of the claims pub, exp, and clx according to the following.<br>
          The signature is calulated on the data from a concatenation as follows:<br> 
          <b>Public key&#124W3C-Gen2&#124Expiry time&#124W3C-Gen2&#124Client context</b><br>
          where "W3C-Gen2" is a case sensitive text string, and "&#124" is a vertical line character.<br>
          Audience (aud) shall be set to the URL "w3.org/gen2".<br>
          JWT ID (jti) shall be set to a UUID that is unique within the domain controlled by the Ecosystem manager.
            </p>
          </section>

          <section data-dfn-for="ags-signed-agtoken">
            <h2>Short term AG Token</h2>
            <p>
          The Short term Access Grant token shall have the following claims in header and payload.<br>
	  <pre class="highlight hljs javascript" aria-busy="false"><span class="hljs-function"></span>          
	  {
            "alg": "HS256",
            "typ": "JWT"
          },
          {
            "iat": 1609452095,
            "exp": 1609459199,
            "clx": "user+app+dev",
            "aud": "w3.org/gen2",
            "jti": "5967e92e-40e8-5f39-892d-cc0da890db1d"
          }
	  </pre>
	  Algorithm (alg) shall be set to "HS256".<br>
	  Type (typ) shall be set to "JWT".<br>
          Issued at (iat) shall be set to the time of token issuance, in Unix time.<br>
          Expiry (exp) shall be set to the time when the token expires, in Unix time.<br>
          Client context (clx) shall be set to the role triplet the client has been assigned. The delimiter separating the roles is a plus sign (+).<br>
          Audience (aud) shall be set to the URL "w3.org/gen2".<br>
          JWT ID (jti) shall be set to a UUID that is unique within the domain controlled by the Ecosystem manager.
            </p>
          </section>
        </section>

        <section data-dfn-for="access-token">
          <h2>Access Token</h2>
          <p>
          The Access token SHALL have the following claims in header and payload.<br>
	  <pre class="highlight hljs javascript" aria-busy="false"><span class="hljs-function"></span>          
	  {
            "alg": "HS256",
            "typ": "JWT"
          },
          {
            "iat": 1609452095,
            "exp": 1609459199,
            "scp": "PurposeX",
            "clx": "user+app+dev",
            "aud": "w3.org/gen2",
            "jti": "5967e93f-40f9-5f39-893e-cc0da890db2e"
          }
	  </pre>
	  Algorithm (alg) shall be set to "HS256".<br>
	  Type (typ) shall be set to "JWT".<br>
          Issued at (iat) shall be set to the time of token issuance, in Unix time.<br>
          Expiry (exp) shall be set to the time when the token expires, in Unix time.<br>
          Scope (scp) shall be set to the Purpose short name, which logically links to the signal scope as defined in the Purpose list.<br>
          Client context (clx) shall be set to the role triplet the client has been assigned. The delimiter separating the roles is a plus sign (+).<br>
          Audience (aud) shall be set to the URL "w3.org/gen2".<br>
          JWT ID (jti) shall be set to a UUID that is unique within the domain controlled by the Ecosystem manager.
          </p>
        </section>
      </section>

      <section data-dfn-for="client-context">
        <h2>Client context</h2>
        <p>
        <em>This section is non-normative.</em><br>
        The Client actor described in the Client chapter is characterized by three subactors:
          <ul>
            <li>The device.</li>
            <li>The application.</li>
            <li>The user of the application.</li>
          </ul>
          Each of these subactors is in turn characterized by a role, 
          building on the concept of a <a href="https://en.wikipedia.org/wiki/Role-based_access_control">Role Based Access Control (RBAC) model</a>. 
          The set of these three roles is called the Client context.<br>
          Gen2 specifies a rudimentary list of roles for each subactor, it is expected that these lists are augmented by the Ecosystem manager, hopefully in a cooperative effort.<br>
          Using an RBAC model provides the following main purposes in the Gen2 access control model:
          <ul>
            <li>Input to the AG server in the Client authentication process.</li>
            <li>Input to the AT server in the Purpose validation.</li>
          </ul>
        The AG server must in the authentication process of the client possibly separately authenticate each of the three subactors. 
        For the AG server to decide on which authentication method to use per subactor can be quite complex, but may be somewhat eased by the Client request for roles for each subactor.<br>
        From a security point of view a Client should not have access to more vehicle signals than are necessary, following the principle of least priviledge. This is achieved by the Purpose document described in the Purpose chapter, that assigns only the for the Purpose relevant signals to the Client. 
        </p>

        <section data-dfn-for="device-roles">
          <h2>Device roles</h2>
          <p>
          Gen2 specifies the following minimum set of roles for devices:
          <ul>
            <li>Vehicle</li>
            <li>Nomadic</li>
            <li>Cloud</li>
            <li>Undefined</li>
          </ul>
          A Vehicle role is used for applications that are deployed in-vehicle, in e. g. the center stack ECU.<br>
          A Nomadic role is used for applications that are deployed in a User's mobile phone, laptop, etc, that uses short range radio communication like Bluetooth, or WiFi.<br>
          A Cloud role is used for applications that are deployed in off-vehicle devices, and uses a long range radio communication like cellular in the connection to the vehicle.<br>
          </p>
        </section>

        <section data-dfn-for="application-roles">
          <h2>Application roles</h2>
          <p>
          Gen2 specifies the following minimum set of roles for applications:
          <ul>
            <li>OEM</li>
            <li>Third party</li>
            <li>Undefined</li>
          </ul>
          An OEM application role is used for applications that are pre-installed in the vehicle by the OEM, or later OEM-provisioned to the vehicle.<br>
          A Third party application role is used for applications that are "certified" for vehicle deployment, but developed by a third party.<br>
          </p>
        </section>

        <section data-dfn-for="user-roles">
          <h2>User roles</h2>
          <p>
          Gen2 specifies the following minimum set of roles for users:
          <ul>
            <li>OEM</li>
            <li>Dealer</li>
            <li>Independent</li>
            <li>Owner</li>
            <li>Driver</li>
            <li>Passenger</li>
            <li>Undefined</li>
          </ul>
          An OEM user is anyone representing the vehicle brand.<br>
          A Dealer user is anyone representing a normally OEM affiliated organisation that provice sale and workshop services for the vehicle.<br>
          An Independent user is anyone representing a normally OEM independent organisation that provide after-market services for the vehicle.<br>
          An Owner user is anyone representing the organisation owning the vehicle.<br>
          A Driver user is anyone driving the vehicle.<br>
          A Passenger user is anyone travelling in the vehicle, but not being the Driver.<br>
          </p>
        </section>
      </section>

      <section data-dfn-for="policy-documents">
        <h2>Policy documents</h2>
        <p>
        <em>This section is non-normative.</em><br>
        The Policy documents are typically owned and created by the Ecosystem manager. They need to be handled securely to protect their integrity. 
        The Ecosystem manager shall securely provision them to the Access Token servers in the access control ecosystem.
        </p>

          <section data-dfn-for="purpose-list">
            <h2>Purpose list</h2>
            <p>
        A Client shall provide a Purpose as input to a request for an Access token. A list of supported purposes needs to exist for a client to select from. The Ecosystem manager shall therefore provide means for Clients to survey the list to find a Purpose that fits its use case.<br>
        Each entry in the list contains a short description of the purpose, which is what the Client shall provide as input to its request for an Access token. There is also a long description, which may be used in the dialogue for consent, if needed. Then there is a list of the Client contexts, i. e. the sub-actor role triplet, that can be granted this access, and last there is a list of  the signals that the client is given access to for this purpose, with the allowed access mode. The list shall use a JSON format as shown in the example below.
        <pre><code>
        {"purposes":
            [{"short": "Pay as you drive", 
            "long": "Insurance cost based on drive data.", 
            "contexts":[ ["OEM", ["OEM", "Third party"], "Vehicle"], [ ] ], 
            "signal_access":
                [{"path": "Vehicle.Drivetrain.Transmission.Speed", "access_mode": "read-only"}, 
                {"path": "Vehicle.Cabin.Infotainment.Navigation.CurrentLocation.Latitude", "access_mode":"read-only"}, 
                {"path": "Vehicle.Cabin.Infotainment.Navigation.CurrentLocation.Longitude", "access_mode": "read-only"}] 
            }, 
            {}] 
        }
        </code></pre>
        The Purpose list shall be securely provisioned to the AT server. The protocol for this is out-of-scope. 
        The AT server must reject all requests for Access tokens if it is not in possession of a Purpose list.
            </p>
          </section>

          <section data-dfn-for="scope-list">
            <h2>Scope list</h2>
            <p>
            The Scope list contains a list of the VSS tree nodes for which access shall be prohibited, per Client context. 
            This prohibition is regardless of whether the Client has a valid Access token or not.<br>
            The Scope list can also be used to limit the node metadata that is returned on a Client service discovery request.<br>
            Each entry in the list contains a list of paths to nodes that should be excluded, and a list of the Client contexts, i. e. the sub-actor role triplet, for which this exclusion should be made.<br>
            The list shall use a JSON format as shown in the example below.
        <pre><code>
        {"scope":
            [{"contexts":[ [ ["Driver", "Passenger"], "Third party", "Vehicle"], [ ] ], 
            "no_access":
                ["Vehicle.Drivetrain.Transmission.Speed", 
                "Vehicle.Cabin.Infotainment.Navigation.CurrentLocation.Latitude", 
                "Vehicle.Cabin.Infotainment.Navigation.CurrentLocation.Longitude"]
            }, 
            {}] 
        }
        </code></pre>
        The Scope list shall be securely provisioned to the AT server. The protocol for this is out-of-scope.
        The AT server shall not restrict the scope for any Client context if it is not in possession of a Scope list.
            </p>
          </section>
      </section>

      <section data-dfn-for="access-control-selection">
        <h2>Access control selection</h2>
        <p>
        <em>This section is non-normative.</em><br>
        This chapter describes a complementary functionality to the access control model, the ability to apply it selectively to parts of the tree. 
        It can be used in cases where not all nodes of the tree are believed to require access control, 
        or read-only is sufficient instead of read-write access control for certain nodes.<br>
        This functionality requires that the Access token specifies whether the access granted to the Client to a signal is read-only, or read-write.
        It also requires that the metadata for the node in the VSS tree contains data specifying whether the access control verification should be carried out only for write request, 
        or for both read and write requests.<br>
        The former requirement is realized as described in earlier chapters by that the Access token scope claim links to a Purpose entry in the Purpose list 
        where the signals and their respective access mode are found.<br>
        The latter requirement is realized by adding to nodes in the VSS tree the key-value pair "validate":'access-control-mode', 
        where 'access-control-mode' is either the string "write-only", or "read-write".<br>
        <figure id="fig-access-control-selection">
          <img src="images/access-control-selection.jpg" alt="Access control selection tagging.">
          <figcaption> <span class="fig-title">Access control selection tagging.</span></figcaption>
        </figure>
        The figure above shows an example where both read and write requests to the three leftmost leaf nodes will be access controlled, 
        while the two rightmost leaf nodes only will be access controlled for write requests. 
        An inheritance rule leads to that any nodes below a tagged node are assigned the same access control, if they are untagged.<br>
        This metadata is not likely to be applied to the standardised VSS tree, as different implementers of this standard may have different views on which nodes to apply it to. 
        Instead it is anticipated that it is applied at a "deployment" stage, possibly using the VSS layering concept.<br>
        The inheritance model, which says that if access-control-mode data is added to a node, then all nodes in the subtree for which this node is the root inherits the setting, 
        unless there is access-control-mode data added to any node in this subtree, makes possible a reduction of the number of nodes this metadata have to be added to.<br>
        This allows for example an entire VSS tree to be assigned an access-control-mode by merely applying it in the root of the tree.<br>
        The figure below shows an overview of the access control selection model, 
        and a table showing the required access control tagging of a node for the Gen2 server to grant the requested access. 
        <figure id="fig-access-control-selection-model">
          <img src="images/access-control-selection-model.jpg" alt="Access control selection model.">
          <figcaption> <span class="fig-title">Access control selection model.</span></figcaption>
        </figure>
        If the VSS tree used by a Gen2 server contains access control selection tags, then the server MUST support their usage as described in this chapter.<br>
        If it is not used, then a server may implement access control for the entire tree.<br>
        </p>
      </section>
    </section>

    <section data-dfn-for="interface">
      <h2>Interface</h2>
      <p>
        This chapter describes the different methods and its arguments that govern the communication between a <a>client</a> and the <a>server</a>.
      </p>
      <section data-dfn-for="methods">
        <h2>Methods</h2>
        <p>
          The transport protocols used to implement these methods MUST implement the Read and Update methods, and MAY implement the Subscribe, Unsubscribe, and Subscription methods. 
        </p>
        <section data-dfn-for="read">
          <h2><dfn>Read</dfn></h2>
          <p>Purpose: Get one or more values addressed by the given path.</p>
          <p>The client MAY have to obtain an <a>authorization</a> token before being able to access the values.
             If the server is able to satisfy the request it MUST return a <a>success response</a>.
             If the server is unable to fulfil the request, then the server MUST return an <a>error response</a>.</p>
          <p>Arguments: 
          <ul>
            <li><a>path</a> The path as defined in VSS to one or more nodes in the VSS tree.</li>
            <li><a>filter</a> Additional information defining the requested data.</li>
            <li><a>authorization</a> The authorization token.</li>
          </ul>
          </p>
          <p>Success response:
            <ul>  
              <li><a>value</a> The value(s) associated with the addressed VSS nodes.</li>
              <li><a>timestamp</a> The sample time of the value.</li>
            </ul>
          </p>
        </section>
        <section data-dfn-for="update">
          <h2><dfn>Update</dfn></h2>
          <p>Purpose: Provide altered value to the vehicle signal(s) addressed by the <a>path</a></p>
          <p>The client MAY have to obtain an authorization token before being able to update the vehicle signal(s).  
             If the server is able to satisfy the request it MUST return a <a>success response</a>. 
             If the server is unable to fulfil the request, then the server MUST return an <a>error response</a>.</p>
          <p>Arguments: 
            <ul>
              <li><a>path</a> The path as defined in VSS to one or more nodes in the VSS tree.</li>
              <li><a>value</a> The value by which the vehicls signals addressed by the path will be updated to.</li>
              <li><a>authorization</a> The authorization token.</li>
            </ul>
          </p>
          <p>Success response:
            <ul>  
              <li><a>timestamp</a> The time for updating of the vehicle signals.</li>
            </ul>
          </p>
        </section>
        <section data-dfn-for="subscribe">
          <h2><dfn>Subscribe</dfn></h2>
          <p>Purpose: Get asynchronous messages containing the value(s) addressed by the path. The triggering rules for issuing the notification messages are set by the filter data.</p>
          <p>The client MAY have to obtain an authorization token before being able to subscribe to the vehicle signal(s).
             The server MUST issue a notification if a trigger rule is fulfilled.
             If the server is able to satisfy the request it MUST return a <a>success response</a>.
             If the server is unable to fulfil the request, then the server MUST return an <a>error response</a>.
             If an error occurs during the subscription period, the server SHOULD return an <a>error notification</a>.</p>
          <p>Arguments: 
            <ul>
              <li><a>path</a> The path as defined in VSS to one or more nodes in the VSS tree.</li>
              <li><a>filter</a> The rule set describing triggering criterias for issuance of asynchronous notification messages.</li>
              <li><a>authorization</a> The authorization token.</li>
            </ul>
          </p>
          <p>Success response:
            <ul>  
              <li><a>subscriptionId</a> A handle identifying notification messages associated with the subscription.</li>
              <li><a>timestamp</a> The start time for the subscription period.</li>
            </ul>
          </p>
        </section>
        <section data-dfn-for="unsubscribe">
          <h2><dfn>Unsubscribe</dfn></h2>
          <p>Purpose: Termination of the subscription period started by a previous subscribe request.</p>
          <p>If the server is able to satisfy the request it MUST return a <a>success response</a>, and it MUST stop issuing notifications associated to the subscription handle.
             If the server is unable to fulfil the request, then the server MUST return an <a>error response</a>.</p>
          <p>Arguments: 
            <ul>
              <li><a>subscriptionId</a> Handle identifying the subscription.</li>
            </ul>
          </p>
          <p>Success response:
            <ul>  
              <li><a>subscriptionId</a> Handle identifying the subscription.</li>
              <li><a>timestamp</a> The stop time for the subscription period.</li>
            </ul>
          </p>
        </section>
        <section data-dfn-for="subscription">
          <h2><dfn>Subscription</dfn></h2>
          <p>Purpose: Asynchronous client notification according to the subscribe request trigger rules.</p>
          <p>The server MUST issue a notification message when a triggering rule associated with the subscription is met.
             If the server cannot fulfill the triggering rules it MUST issue an error notification and terminate the subscription. 
          </p>
          <p>Arguments: 
            <ul>
              <li><a>subscriptionId</a> Handle identifying the subscription.</li>
              <li><a>value</a> The value(s) associated with the node(s) being addressed in the subscribe request.</li>
              <li><a>timestamp</a> The time for the trigger activation.</li>
            </ul>
          </p>
        </section>
      </section>
      <section data-dfn-for="error-information">
        <h2>Error information</h2>
        <p>The server MUST inform a client about errors ocurring in interactions between the two, whether it is in a synchronous <a>error response</a> to a request message, or an asynchronous <a>error notification</a> message.
        </p>
        <section data-dfn-for="error-format">
          <h2>Error format</h2>
          <p>The error information has three components - a <a>number</a>, a <a>reason</a>, and a <a>message</a>. The number MUST always be part of the error information, 
             while the reason and message components MAY be a part of it.
            <ul>
              <li><dfn data-dfn-type="dfn" id="dfn-error-number">number</dfn> See Gen2:TRANSPORT, "Status code" chapter.</li>
              <li><dfn data-dfn-type="dfn" id="dfn-error-reason">reason</dfn> See Gen2:TRANSPORT, "Status code" chapter.</li>
              <li><dfn data-dfn-type="dfn" id="dfn-error-message">message</dfn> See Gen2:TRANSPORT, "Status code" chapter.</li>
            </ul>
          </p>
          </section>
      </section>
      <section data-dfn-for="security">
        <h2>Security</h2>
        <p>
        </p>
      </section>
      <section data-dfn-for="timestamp">
        <h2>Timestamps</h2>
        <p>
           Timestamps in transport payloads MUST conform to the ISO8601 standard, using the UTC format with a trailing Z. 
           Time resolution SHALL at least be seconds, with subsecond resolution as an optional degree of precision when desired.
           The time and date format shall be as shown below, where the sub-second data and delimiter is optional.<br>
           YYYY-MM-DDTHH:MM:SS.ssssssZ<br>
           The exception to this is timestamps within tokens, which MUST conform to Unix time. 
        </p>
      </section>
        <section id="definitions">
          <h2>Definitions</h2>
	<p></p>

	<dl title="enum Defs" class="idl">
	  <dt><dfn data-dfn-type="dfn" id="dfn-client">client</dfn></dt>
	  <dd>An entity that works with data managed by a server.</dd>
	  <dt><dfn data-dfn-type="dfn" id="dfn-server">server</dfn></dt>
	  <dd>An entity that manages and offers access to data.</dd>
          <dt><dfn data-dfn-type="dfn" id="dfn-success-response">success response</dfn></dt>
          <dd>The message being returned by the server to the client when no error is encountered. These are specific per request type</dd>
	  <dt><dfn data-dfn-type="dfn" id="dfn-error-response">error response</dfn></dt>
	  <dd>The message being returned by the server to the client when an error is encountered. These have a common format for all request types</dd>
	  <dt><dfn data-dfn-type="dfn" id="dfn-error-notification">error notification</dfn></dt>
	  <dd>The asynchronous message being returned by the server to the client when an error is encountered.</dd>
	  <dt><dfn data-dfn-type="dfn" id="dfn-value">value</dfn></dt>
	  <dd>The data that is associated with one or more VSS nodes. Regardless of its data type, a single data item is always represented as a string in message payloads.</dd>
          <dt><dfn data-dfn-type="dfn" id="dfn-timestamp">timestamp</dfn></dt>
          <dd>A date and time representation. See chapter "Timestamps".</dd>
	  <dt><dfn data-dfn-type="dfn" id="dfn-filter">filter</dfn></dt>
	  <dd>Additional to help the server in the selection of data for the client.</dd>
	  <dt><dfn data-dfn-type="dfn" id="dfn-query">query</dfn></dt>
	  <dd>A filter may consist of multiple query expressions.</dd>
	  <dt><dfn data-dfn-type="dfn" id="dfn-authorization">authorization</dfn></dt>
	  <dd>A token providing a verifiable proof that the client may be authorized access to the requested value(s).</dd>
	  <dt><dfn data-dfn-type="dfn" id="dfn-subscription-id">subscriptionId</dfn></dt>
	  <dd>A handle identifying a subscription session.</dd>
	</dl>
      </section>
    </section>
    <section id="dynamic-registry-api" class="appendix">
      <h4>Dynamic registry API</h4>
      <p>The dynamic reqistry API provides the functionality to dynamically add or delete branches of the VSS tree. A branch can only be deleted if it has been dynamically added. In the following an entity requesting dynamic registry services is called a "service manager", and the entity performing these requests is called the "core server", see the figure "Gen2 server reference architecure".</p>
    </section>
    <section id="tof" class="appendix"></section>
  </body>
</html>
